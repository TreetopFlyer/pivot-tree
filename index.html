<style>
.Row
{
    padding-left:20px;
    overflow:hidden;
    clear:both;
}
.Row > .Name
{
    float:left;
}
.Row > .Columns
{
    float:right;
    overflow:hidden;
}
.Columns > .Cell
{
    width:120px;
    float:left;
    border:1px solid #333;
    padding:5px;

    text-align:right;
}
.Section
{
    clear:both;
}
.Pivot
{
    float:left;
    border:1px solid #000;
    margin:5px;
}
.Pivot span
{
    display:inline-block;
    padding:10px;
    margin:3px;
    background:#FC0;
}
th
{
    border-bottom:1px solid #333;
    text-align:center;
}
td
{
    text-align:right;
    padding:3px 0px 20px 10px;
}
td.Value
{
    padding-left:40px;
    background:#ddd;
    font-weight:bold;
    text-align:right;
}
td.Goal
{
    padding-right:20px;
}
</style>
<div id="App"></div>
<script type="module">
import { html, render } from 'https://unpkg.com/lit-html/lit-html.js';
import { Pivot, Tweak, PathDown, PathUp } from './pivot.js';

var App;
App = {
    Model: {
        Display:[ "Thing", "Type", "Cost", "Count"],
        Keys:   [ "thing", "type", "cost", "count"],
        Sums:   [                  "cost", "count"],
        Pivots: [ "thing", "type"                 ],
        Rows:   [
                ["thing1",    "a",      1,       1],
                ["thing1",    "b",      2,       1],
                ["thing1",    "a",      3,       2],
                ["thing1",    "b",      4,       2],
                ["thing2",    "a",      1,       2],
                ["thing2",    "b",      2,       2],
                ["thing2",    "a",      3,       2],
                ["thing2",    "b",      4,       2],
                ["thing2",    "a",      5,       1],
                ["thing2",    "b",      6,       1],
                ["thing2",    "a",      7,       1]
                ],
        Trees:  [],
        Active:false,
        Form:{
            Pivot:{
                Open:[],
                Closed:[]
            }
        },
        History:[],
        Epoch:0
    },
    Methods: {
        Prep: ()=>
        {
            var i, j;
            var indicies;
            var index, row;
            indicies = App.Methods.GetColumnIndicies(App.Model.Sums);
            for(i=0; i<indicies.length; i++)
            {
                index = indicies[i];
                for(j=0; j<App.Model.Rows.length; j++)
                {
                    row = App.Model.Rows[j];
                    row[index] = {Original:row[index], Modified:0, Epoch:0}
                }
            }
        },
        FormPivotReset: () =>
        {
            var form;
            form = App.Model.Form.Pivot;
            form.Open = App.Methods.GetColumnIndicies(App.Model.Pivots);
            form.Closed = [];
            App.Render.Update(App.Model, App.Methods);
        },
        FormPivotUpdate: (inIndex) =>
        {
            var form;
            form = App.Model.Form.Pivot;
            form.Closed.push(form.Open.splice(inIndex, 1)[0]);
            App.Render.Update(App.Model, App.Methods);
        },
        FormPivotSubmit: ()=>
        {
            var i;
            var joiner;
            var tree;
            var check;
            var against;

            joiner = "|>-";
            check = App.Model.Form.Pivot.Closed.join(joiner);
            for(i=0; i<App.Model.Trees.length; i++)
            {
                tree = App.Model.Trees[i];
                against = tree.Pivot.join(joiner);
                if(check == against)
                {
                    App.Methods.PivotSelect(tree);
                    return;
                }
            }
            App.Methods.PivotCreate(App.Model.Form.Pivot.Closed);
            App.Methods.FormPivotReset();
        },
        InferTable: (inTree, inArray) =>
        {
            return PathDown(inTree.Root, inArray, 0);
        },
        InferColumn: (inTable, inKey) =>
        {
            var indexColumn;
            var i;
            var column;

            indexColumn = App.Methods.GetColumnIndex(inKey);
            for(i=0; i<inTable.Sums.length; i++)
            {
                column = inTable.Sums[i];
                if(column.IndexColumn == indexColumn)
                {
                    return column;
                }
            }
            return false;
        },
        GetColumnKey:(inIndex)=>
        {
            return App.Model.Keys[inIndex];
        },
        GetColumnKeys:(inIndexArray)=>
        {
            var i;
            var output;
            output = [];
            for(i=0; i<inIndexArray.length; i++)
            {
                output[i] = App.Methods.GetColumnKey(inIndexArray[i]);
            }
            return output;
        },
        GetColumnIndex:(inKey)=>
        {
            var i;
            for(i=0; i<App.Model.Keys.length; i++)
            {
                if(App.Model.Keys[i] == inKey)
                {
                    return i;
                }
            }
            return false;
        },
        GetColumnIndicies:(inKeyArray)=>
        {
            var i;
            var output;
            output = [];
            for(i=0; i<inKeyArray.length; i++)
            {
                output[i] = App.Methods.GetColumnIndex(inKeyArray[i]);
            }
            return output;
        },
        EditCreate: (inTable, inIndex, inAmount) =>
        {
            Tweak(inTable, inIndex, inAmount)
            App.Render.Update(App.Model, App.Methods);
        },
        EditDelete: (inTable, inIndex)=>
        {
            Tweak(inTable, inIndex, 0)
            App.Render.Update(App.Model, App.Methods);
        },
        GoalCreate: (inTable, inIndex, inAmount) =>
        {
            var column;
            column = inTable.Sums[inIndex];
            column.Goal = inAmount;
            App.Render.Update(App.Model, App.Methods);
        },
        GoalDelete: (inTable, inIndex) =>
        {
            App.Methods.GoalCreate(inTable, inIndex, 0);
        },
        PivotCreate: (inArray) =>
        {
            var i;
            var tree;
            tree = {
                Pivot: inArray,
                Root: Pivot(App.Model.Rows, inArray, App.Methods.GetColumnIndicies(App.Model.Sums))
            };
            App.Model.Trees.push(tree);
            App.Model.Active = tree;
            App.Render.Update(App.Model, App.Methods);
            return tree;
        },
        PivotSelect: (inPivot)=>
        {
            App.Model.Active = inPivot;
            App.Render.Update(App.Model, App.Methods);
        },
        PivotDelete: (inPivot) =>
        {
            var i;
            for(i=0; i<App.Model.Trees.length; i++)
            {
                if(App.Model.Trees[i] == inPivot)
                {
                    if(App.Model.Active == inPivot)
                    {
                        App.Model.Active = false;
                    }
                    App.Model.Trees.splice(i, 1);
                }
            }
            App.Render.Update(App.Model, App.Methods);
        },
        StatePivot: (inTable, inList) =>
        {
            var i;
            var sum;
            var outputTable;
            var outputColumn;

            outputTable = {
                Path:[],
                Columns:[]
            };
            for(i=0; i<inTable.Sums.length; i++)
            {
                outputColumn = {};
                sum = inTable.Sums[i];
                if(sum.Local != 1)
                {
                    outputColumn.Column = sum.IndexColumn;
                    outputColumn.Edit = sum.Local
                }
                if(sum.Goal != 0)
                {
                    outputColumn.Column = sum.IndexColumn;
                    outputColumn.Goal = sum.Goal;
                }
                if(outputColumn.Column > -1)
                {
                    outputColumn.Column = App.Methods.GetColumnKey(outputColumn.Column);
                    outputTable.Columns.push(outputColumn);
                }
            }
            if(outputTable.Columns.length != 0)
            {
                outputTable.Path = PathUp(inTable, []);
                outputTable.Path.shift();
                inList.push(outputTable);
            }
            for(i=0; i<inTable.Children.length; i++)
            {
                App.Methods.StatePivot(inTable.Children[i], inList);
            }
            return inList;
        },
        StateSave: () =>
        {
            var i;
            var output;
            var pivot;
            var tree;

            output = {
                Data:{
                    Source:"",
                    Destination:"",
                },
                Pivots:[]
            };

            for(i=0; i<App.Model.Trees.length; i++)
            {
                tree = App.Model.Trees[i];
                pivot = {
                    Pivot:App.Methods.GetColumnKeys(tree.Pivot),
                    Changes:App.Methods.StatePivot(tree.Root, []),
                };
                output.Pivots.push(pivot);
            }
            App.Model.History.unshift(output);
            App.Render.Update(App.Model, App.Methods);
            return output;
        },
        StateLoad: (inState) => 
        {
            var i, j, k;
            var tree;
            var table;
            var column;
            var appTree;
            var appTable;
            var appColumn;

            App.Model.Trees = [];
            App.Model.Active = false;

            for(i=0; i<inState.Pivots.length; i++)
            {
                tree = inState.Pivots[i];
                appTree = App.Methods.PivotCreate(App.Methods.GetColumnIndicies(tree.Pivot));
                for(j=0; j<tree.Changes.length; j++)
                {
                    table = tree.Changes[j];
                    appTable = App.Methods.InferTable(appTree, table.Path);

                    for(k=0; k<table.Columns.length; k++)
                    {
                        column = table.Columns[k];
                        appColumn = App.Methods.InferColumn(appTable, column.Column);
                        if(column.Edit)
                        {
                            App.Methods.EditCreate(appTable, appColumn.IndexSum, column.Edit);
                        }
                        if(column.Goal)
                        {
                            App.Methods.GoalCreate(appTable, appColumn.IndexSum, column.Goal);
                        }
                    }
                }
            }
        }
    },
    Render: {
        Update: (inModel, inMethods) =>
        {
            render( App.Render.Layout(inModel, inMethods), document.querySelector("#App"));
        },
        Layout: (inModel, inMethods) =>
        {
            return html`
            <div class="Section">
                <h3>State</h3>
                <button @click=${ ()=>{inMethods.StateSave();} }>Save</button>
                ${inModel.History.map( (inItem, inIndex)=>{
                    return html`<button @click=${ ()=>{inMethods.StateLoad(inModel.History[inIndex]);} }>${inIndex}</button>`;
                } )}
            </div>
            <div class="Section">
                <h3>Pivots</h3>
                ${App.Render.FormPivot(inModel, inMethods)}
            </div>
            <div class="Section">
                <h3>View</h3>
                ${App.Render.Tree(inModel, inMethods)}
            </div>
            `;
        },
        FormPivot: (inModel, inMethods) =>
        {
            return html`
            <div>
                <ul>
                    ${inModel.Form.Pivot.Closed.map( (inItem)=>{
                        return html`<li>${inModel.Display[inItem]}</li>`
                    })}
                </ul>
                <select @change=${(inEvent)=>{ inMethods.FormPivotUpdate(inEvent.target.selectedIndex-1); inEvent.target.selectedIndex = 0; }}>
                    <option>Add column</option>
                    ${inModel.Form.Pivot.Open.map( (inItem)=>
                    {
                        return html`<option>${inModel.Display[inItem]}</option>`
                    })}
                </select>
                <button @click=${ ()=>{inMethods.FormPivotSubmit();}}>
                    Create
                </button>
                <button @click=${ ()=>{inMethods.FormPivotReset();}}>
                    Cancel
                </button>

            </div>
            `;
        },
        Tree: (inModel, inMethods) =>
        {
            if(!inModel.Active)
            {
                return false;
            }
            return html`
            <table cellpadding="0" cellspacing="0">
                <tr>
                    <th class="Column"></th>
                    ${inModel.Sums.map( (inItem)=>
                    {
                        return html`
                        <th class="Value">(${inItem}</th>
                        <th class="Outside">+O)</th>
                        <th class="Local">xL</th>
                        <th class="Parent">xP</th>
                        <th class="Child">+C</th>
                        <th class="Total">=T</th>
                        <th class="Goal">-G)</th>`;
                    })}
                </tr>
                ${inModel.Active.Root.Children.map( (inBranch)=>{
                    return App.Render.Branch(inBranch, inMethods, []);
                })}
            </table>
            `;
        },
        Branch: (inModel, inMethods, inPath) =>
        {
            var path = inPath.concat([inModel.Name]);
            return html`
            <tr>
                <td>
                    ${path.join("/")}
                </td>
                ${inModel.Sums.map( (inItem, inIndex)=>{

                    var total;
                    var markupGoal;
                    total = inItem.Value * inItem.Local * inItem.Parent + inItem.Child;
                    if(inItem.Goal != 0)
                    {
                        markupGoal = html`${inItem.Goal}`;
                    }
                    else
                    {
                        markupGoal = html`<button @click=${()=>{inMethods.GoalCreate(inModel, inIndex, 100)} }>+</button>`;
                    }

                    return html`
                    <td class="Value" @click=${ ()=>{inMethods.EditCreate(inModel, inIndex, 1.33);} }>
                        ${inItem.Value.toFixed(2)}
                    </td>
                    <td class="Outside">${inItem.Outside}</td>
                    <td class="Local">${inItem.Local}</td>
                    <td class="Parent">${inItem.Parent}</td>
                    <td class="Child">${inItem.Child}</td>
                    <td class="Total">${total.toFixed(2)}</td>
                    <td class="Goal">${markupGoal}</td>
                    `;
                } )}
            </tr>
            ${inModel.Children.map( (inItem)=>{
                return App.Render.Branch(inItem, inMethods, path);
            } )}
            `;
        }
    }
};

App.Methods.Prep();
App.Methods.FormPivotReset();
console.log(App.Model);
</script>