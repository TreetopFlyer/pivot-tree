<style>
.Row
{
    padding-left:20px;
    overflow:hidden;
    clear:both;
}
.Row > .Name
{
    float:left;
}
.Row > .Columns
{
    float:right;
    overflow:hidden;
}
.Columns > .Cell
{
    width:120px;
    float:left;
    border:1px solid #333;
    padding:5px;

    text-align:right;
}
.Section
{
    clear:both;
}
.Pivot
{
    float:left;
    border:1px solid #000;
    margin:5px;
}
.Pivot span
{
    display:inline-block;
    padding:10px;
    margin:3px;
    background:#FC0;
}
th
{
    border-bottom:1px solid #333;
    text-align:center;
}
td
{
    text-align:right;
    padding:3px 0px 20px 10px;
}
td.Value
{
    padding-left:40px;
    background:#ddd;
    font-weight:bold;
    text-align:right;
}
td.Goal
{
    padding-right:20px;
}
</style>
<div id="App"></div>
<script type="module">
import { html, render } from 'https://unpkg.com/lit-html/lit-html.js';
import { Pivot, Tweak, PathDown, PathUp } from './pivot.js';

var App;
App = {
    Model: {
        Header: [
                    {Display:"Thing", Key:"thing", Sum:false, Pivot:true },
                    {Display:"Type",  Key:"type",  Sum:false, Pivot:true },
                    {Display:"Cost",  Key:"cost",  Sum:true,  Pivot:false},
                    {Display:"Count", Key:"count", Sum:true,  Pivot:false},
                ],
        Sums:   [],
        Pivots: [],
        Rows:   [
                    ["thing1", "a",  1,  1  ],
                    ["thing1", "b",  2,  1  ],
                    ["thing1", "a",  3,  2  ],
                    ["thing1", "b",  4,  2  ],
                    ["thing2", "a",  1,  2  ],
                    ["thing2", "b",  2,  2  ],
                    ["thing2", "a",  3,  2  ],
                    ["thing2", "b",  4,  2  ],
                    ["thing2", "a",  5,  1  ],
                    ["thing2", "b",  6,  1  ],
                    ["thing2", "a",  7,  1  ]
                ],
        Trees:  [],
        Active:false,
        Form:{
            Pivot:{
                Open:[],
                Closed:[]
            }
        },
        History:[],
        Epoch:0
    },
    Methods: {
        Prep: ()=>
        {
            var i, j;
            var header, row;
            for(i=0; i<App.Model.Header.length; i++)
            {
                header = App.Model.Header[i];
                header.Index = i;
                if(header.Sum)
                {
                    App.Model.Sums.push(header);
                    for(j=0; j<App.Model.Rows.length; j++)
                    {
                        row = App.Model.Rows[j];
                        row[i] = {Original:row[i], Scale:1, Epoch:0}
                    }
                }
                if(header.Pivot)
                {
                    App.Model.Pivots.push(header);
                }
            }
        },
        FormPivotReset: () =>
        {
            var form;
            form = App.Model.Form.Pivot;
            form.Open = App.Model.Pivots.slice();
            form.Closed = [];
            App.Render.Update(App.Model, App.Methods);
        },
        FormPivotUpdate: (inIndex) =>
        {
            var form;
            form = App.Model.Form.Pivot;
            form.Closed.push(form.Open.splice(inIndex, 1)[0]);
            console.log("picot list is now:", form.Closed);
            App.Render.Update(App.Model, App.Methods);
        },
        FormPivotSubmit: ()=>
        {
            var form;
            var keys;
            var i;

            form = App.Model.Form.Pivot;
            keys = [];
            for(i=0; i<form.Closed.length; i++)
            {
                keys.push(form.Closed[i].Key);
            }
            App.Methods.FormPivotReset();
            App.Methods.PivotCreate(keys);
        },
        InferPivot: (inTrees, inArray) => 
        {
            var i, j;
            var joiner;
            var tree;
            var check;
            var against;

            joiner = "|>-";
            check = inArray.join(joiner);
            for(i=0; i<inTrees.length; i++)
            {
                tree = inTrees[i];
                against = tree.Pivot.join(joiner);
                if(check == against)
                {
                    return tree;
                }
            }
            return false;
        },
        InferTable: (inTree, inArray) =>
        {
            return PathDown(inTree.Root, inArray, 0);
        },
        InferColumn: (inTable, inKey) =>
        {
            var sumIndex = App.Methods.MapSumIndex(inKey);
            var lookup = inTable.Sums[sumIndex]
            return lookup;
        },
        MapSumIndex: (inKey) =>
        {
            var i;
            var sum;
            for(i=0; i<App.Model.Sums.length; i++)
            {
                if(App.Model.Sums[i] == inKey)
                {
                    return i;
                }
            }
        },
        MapSumKey: (inIndex) =>
        {
            return App.Model.Sums[inIndex];
        },
        EditCreate: (inTable, inIndex, inAmount) =>
        {
            Tweak(inTable, inIndex, inAmount)
            App.Render.Update(App.Model, App.Methods);
        },
        EditDelete: (inTable, inIndex)=>
        {
            Tweak(inTable, inIndex, 0)
            App.Render.Update(App.Model, App.Methods);
        },
        GoalCreate: (inTable, inIndex, inAmount) =>
        {
            var column;
            column = inTable.Sums[inIndex];
            column.Goal = inAmount;
            App.Render.Update(App.Model, App.Methods);
        },
        GoalDelete: (inTable, inIndex) =>
        {
            App.Methods.GoalCreate(inTable, inIndex, 0);
        },
        PivotCreate: (inArray) =>
        {
            var i;
            var tree;
            var indiciesSums;
            var indiciesPivots
            var check;

            console.log("creating pivot", inArray, "...");
            check = App.Methods.InferPivot(App.Model.Trees, inArray)
            if(check)
            {
                ("...already exists");
                App.Model.Active = check;
                App.Render.Update(App.Model, App.Methods);
                return;
            }
            console.log("...its new!");
            tree = {
                Pivot: inArray,
                Root: Pivot(App.Model.Rows, App.Model.Pivots, App.Model.Sums)
            };
            App.Model.Trees.push(tree);
            App.Model.Active = tree;
            App.Render.Update(App.Model, App.Methods);
            return tree;
        },
        PivotSelect: (inPivot)=>
        {
            App.Model.Active = inPivot;
            App.Render.Update(App.Model, App.Methods);
        },
        PivotDelete: (inPivot) =>
        {
            var i;
            for(i=0; i<App.Model.Trees.length; i++)
            {
                if(App.Model.Trees[i] == inPivot)
                {
                    if(App.Model.Active == inPivot)
                    {
                        App.Model.Active = false;
                    }
                    App.Model.Trees.splice(i, 1);
                }
            }
            App.Render.Update(App.Model, App.Methods);
        },
        StatePivot: (inTable, inList) =>
        {
            var i;
            var sum;
            var outputTable;
            var outputColumn;

            outputTable = {
                Path:[],
                Columns:[]
            };
            for(i=0; i<inTable.Sums.length; i++)
            {
                outputColumn = {};
                sum = inTable.Sums[i];
                if(sum.Local != 1)
                {
                    outputColumn.Column = i;
                    outputColumn.Edit = sum.Local
                }
                if(sum.Goal != 0)
                {
                    outputColumn.Column = i;
                    outputColumn.Goal = sum.Goal;
                }
                if(outputColumn.Column > -1)
                {
                    outputColumn.Column = App.Methods.MapSumKey(i);
                    outputTable.Columns.push(outputColumn);
                }
            }
            if(outputTable.Columns.length != 0)
            {
                outputTable.Path = PathUp(inTable, []);
                outputTable.Path.shift();
                inList.push(outputTable);
            }
            for(i=0; i<inTable.Children.length; i++)
            {
                App.Methods.StatePivot(inTable.Children[i], inList);
            }
            return inList;
        },
        StateSave: () =>
        {
            var i;
            var output;
            var pivot;
            var tree;

            output = {
                Data:{
                    Source:"",
                    Destination:"",
                },
                Pivots:[]
            };

            for(i=0; i<App.Model.Trees.length; i++)
            {
                tree = App.Model.Trees[i];
                pivot = {
                    Pivot:tree.Pivot,
                    Changes:App.Methods.StatePivot(tree.Root, []),
                };
                output.Pivots.push(pivot);
            }
            App.Model.History.unshift(output);
            App.Render.Update(App.Model, App.Methods);
            return output;
        },
        StateLoad: (inState) => 
        {
            var i, j, k;
            var tree;
            var table;
            var column;
            var appTree;
            var appTable;
            var appColumn;

            App.Model.Trees = [];
            App.Model.Active = false;

            for(i=0; i<inState.Pivots.length; i++)
            {
                tree = inState.Pivots[i];
                appTree = App.Methods.PivotCreate(tree.Pivot);
                for(j=0; j<tree.Changes.length; j++)
                {
                    table = tree.Changes[j];
                    appTable = App.Methods.InferTable(appTree, table.Path);

                    for(k=0; k<table.Columns.length; k++)
                    {
                        column = table.Columns[k];
                        appColumn = App.Methods.InferColumn(appTable, column.Column);
                        if(column.Edit)
                        {
                            App.Methods.EditCreate(appTable, appColumn.IndexSum, column.Edit);
                        }
                        if(column.Goal)
                        {
                            App.Methods.GoalCreate(appTable, appColumn.IndexSum, column.Goal);
                        }
                    }
                }
            }
        }
    },
    Render: {
        Update: (inModel, inMethods) =>
        {
            render( App.Render.Layout(inModel, inMethods), document.querySelector("#App"));
        },
        Layout: (inModel, inMethods) =>
        {
            return html`
            <div class="Section">
                <h3>State</h3>
                <button @click=${ ()=>{inMethods.StateSave();} }>Save</button>
                ${inModel.History.map( (inItem, inIndex)=>{
                    return html`<button @click=${ ()=>{inMethods.StateLoad(inModel.History[inIndex]);} }>${inIndex}</button>`;
                } )}
            </div>
            <div class="Section">
                <h3>Pivots</h3>
                ${App.Render.FormPivot(inModel.Form.Pivot, inMethods)}
            </div>
            <div class="Section">
                <h3>View</h3>
                ${App.Render.Tree(inModel, inMethods)}
            </div>
            `;
        },
        FormPivot: (inModel, inMethods) =>
        {
            return html`
            <div>
                <ul>
                    ${inModel.Closed.map( (inItem, inIndex)=>{
                        return html`<li>${inItem.Display}</li>`
                    })}
                </ul>
                <select @change=${(inEvent)=>{ inMethods.FormPivotUpdate(inEvent.target.selectedIndex-1); inEvent.target.selectedIndex = 0; }}>
                    <option>Add column</option>
                    ${inModel.Open.map( (inItem, inIndex)=>
                    {
                        return html`<option>${inItem.Display}</option>`
                    })}
                </select>
                <button @click=${ ()=>{inMethods.FormPivotSubmit();}}>
                    Create
                </button>
                <button @click=${ ()=>{inMethods.FormPivotReset();}}>
                    Cancel
                </button>

            </div>
            `;
        },
        Tree: (inModel, inMethods) =>
        {
            if(!inModel.Active)
            {
                return false;
            }
            return html`
            <table cellpadding="0" cellspacing="0">
                <tr>
                    <th class="Column"></th>
                    ${inModel.Sums.map( (inItem)=>
                    {
                        return html`
                        <th class="Value">${inItem.Display}</th>
                        <th class="Local">(xL</th>
                        <th class="Parent">xP</th>
                        <th class="Child">+C</th>
                        <th class="Total">=T</th>
                        <th class="Goal">-G)</th>`;
                    })}
                </tr>
                ${inModel.Active.Root.Children.map( (inBranch)=>{
                    return App.Render.Branch(inBranch, inMethods, []);
                })}
            </table>
            `;
        },
        Branch: (inModel, inMethods, inPath) =>
        {
            var path = inPath.concat([inModel.Name]);
            return html`
            <tr>
                <td>
                    ${path.join("/")}
                </td>
                ${inModel.Sums.map( (inItem, inIndex)=>{

                    var total;
                    var markupGoal;
                    total = inItem.Value * inItem.Local * inItem.Parent + inItem.Child;
                    if(inItem.Goal != 0)
                    {
                        markupGoal = html`${inItem.Goal}`;
                    }
                    else
                    {
                        markupGoal = html`<button @click=${()=>{inMethods.GoalCreate(inModel, inIndex, 100)} }>+</button>`;
                    }

                    return html`
                    <td class="Value" @click=${ ()=>{inMethods.EditCreate(inModel, inIndex, 1.33);} }>
                        ${inItem.Value.toFixed(2)}
                    </td>
                    <td class="Local">${inItem.Local}</td>
                    <td class="Parent">${inItem.Parent}</td>
                    <td class="Child">${inItem.Child}</td>
                    <td class="Total">${total.toFixed(2)}</td>
                    <td class="Goal">${markupGoal}</td>
                    `;
                } )}
            </tr>
            ${inModel.Children.map( (inItem)=>{
                return App.Render.Branch(inItem, inMethods, path);
            } )}
            `;
        }
    }
};

App.Methods.Prep();
App.Methods.FormPivotReset();
</script>